library IEEE; 
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_UNSIGNED.all;
use IEEE.STD_LOGIC_ARITH.all;

entity fpadd is
 port(a, b: in STD_LOGIC_VECTOR(31 downto 0);
 	s: out STD_LOGIC_VECTOR(31 downto 0));
end;
architecture synth of fpadd is

 component expcomp
	 port(expa, expb: in STD_LOGIC_VECTOR(7 downto 0);
		alessb: inout STD_LOGIC;
 		exp,shamt: out STD_LOGIC_VECTOR(7 downto 0));
 end component;

 component shiftmant
 	port(alessb: in STD_LOGIC;
 		manta: in STD_LOGIC_VECTOR(23 downto 0);
 		mantb: in STD_LOGIC_VECTOR(23 downto 0);
		shamt: in STD_LOGIC_VECTOR(7 downto 0);
 		shmant: out STD_LOGIC_VECTOR(23 downto 0));
 end component;

 component addmant
 	port(alessb: in STD_LOGIC;
 		manta: in STD_LOGIC_VECTOR(23 downto 0);
 		mantb: in STD_LOGIC_VECTOR(23 downto 0);
 		shmant: in STD_LOGIC_VECTOR(23 downto 0);
		exp_pre: in STD_LOGIC_VECTOR(7 downto 0);
		fract: out STD_LOGIC_VECTOR(22 downto 0);
 		exp: out STD_LOGIC_VECTOR(7 downto 0));
 end component;

 signal expa, expb: STD_LOGIC_VECTOR(7 downto 0);
 signal exp_pre, exp: STD_LOGIC_VECTOR(7 downto 0);
 signal shamt: STD_LOGIC_VECTOR(7 downto 0);
 signal alessb: STD_LOGIC;
 signal manta: STD_LOGIC_VECTOR(23 downto 0);
 signal mantb: STD_LOGIC_VECTOR(23 downto 0);
 signal shmant: STD_LOGIC_VECTOR(23 downto 0);
 signal fract: STD_LOGIC_VECTOR(22 downto 0);

begin
 expa <= a(30 downto 23);
 manta <= '1' & a(22 downto 0);
 expb <= b(30 downto 23);
 mantb <= '1' & b(22 downto 0);
 s <= '0' & exp & fract;
 expcomp1: expcomp 
 port map(expa, expb, alessb, exp_pre, shamt);
 shiftmant1: shiftmant
 port map(alessb, manta, mantb, shamt, shmant);
 addmant1: addmant
 port map(alessb, manta, mantb, shmant, 
 exp_pre, fract, exp);
end;
