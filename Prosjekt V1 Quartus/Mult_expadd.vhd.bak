library IEEE; 
use IEEE.STD_LOGIC_1164.all;
use ieee.numeric_std.all;
--use IEEE.std_logic_unsigned.all;

ENTITY Mult_expadd IS 
PORT(	CLK	:	IN STD_LOGIC;
		RST	:	IN	STD_LOGIC;
		Tall_a, Tall_b	:	IN	unsigned(31 DOWNTO 0);
		Tall_s	:	OUT unsigned(31 DOWNTO 0));
END;



Architecture Struct of Mult_expadd IS

component Z_COUNTER IS
	GENERIC(	n	:	NATURAL);
	PORT(CLK		:	IN	STD_LOGIC;
		  Enable	:	IN	STD_LOGIC;
		  RST		:	IN	STD_LOGIC;
		  X		:	IN	UNSIGNED(n-1 DOWNTO 0);
		  Num_Z	:	OUT NATURAL);
END component;

SIGNAL	sign_a, sign_b, sign_s	:	STD_LOGIC := '0';
SIGNAL	exp_a, exp_b, exp_s		:	unsigned(7 DOWNTO 0) := (OTHERS => '0');
SIGNAL	fract_a, fract_b, fract_s	:	unsigned(22 DOWNTO 0) := (OTHERS => '0');
SIGNAL 	fract_s_m	:	unsigned(45 DOWNTO 0) := (OTHERS => '0');
SIGNAL 	Num_z		:	NATURAL := 0;

BEGIN
	sign_a <= Tall_a(31);
	sign_b <= Tall_b(31);
	
	exp_a <= Tall_a(30 DOWNTO 23);
	exp_b <= Tall_b(30 DOWNTO 23);
	
	fract_a <= Tall_a(22 DOWNTO 0);
	fract_b <= Tall_b(22 DOWNTO 0);
	
	sign_s <= sign_a XOR sign_b;
	
	exp_s_m <= exp_a + exp_b;
	
	fract_s_m <= fract_a * fract_b;
	

	
	Norm : Z_COUNTER 	GENERIC MAP (n => 46) 
								PORT MAP (CLK => CLK, Enable => '1', RST => RST, x => fract_s_m, Num_Z => Num_z);
						
	fract_s_m2 <= shift_left(fract_s_m,Num_z);
	fract_s <= fract_s_m2(45 DOWNTO 23);
	exp_s <= exp_s_m - to_unsigned(Num_z, exp_s'length);
	
	
	Tall_s <= (sign_s & exp_s) & fract_s;						
END Struct;

